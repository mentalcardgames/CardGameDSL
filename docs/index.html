<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Domain Specific Language For Card Games (in Rust)</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f9;
            color: #333;
        }

        header {
            background-color: #2c3e50;
            color: white;
            padding: 20px;
            text-align: center;
        }

        header h1 {
            margin: 0;
        }

        .container {
            width: 90%;
            margin: 20px auto;
        }

        .section {
            margin-bottom: 40px;
        }

        .section h2 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 10px;
        }

        .section h3 {
            color: #2c3e50;
            border-bottom: 2px solid #ecf0f1;
            padding-bottom: 5px;
        }
        .section p {
            line-height: 1.6;
        }

        .code-block {
            background-color: #2d3436;
            color: #ecf0f1;
            padding: 20px;
            border-radius: 5px;
            overflow-x: auto;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .code-block pre {
            margin: 0;
        }

        footer {
            text-align: center;
            padding: 20px;
            background-color: #2c3e50;
            color: white;
        }

        footer a {
            color: #ecf0f1;
            text-decoration: none;
        }

        footer a:hover {
            text-decoration: underline;
        }
    </style>
    <!-- Prism CSS for syntax colors -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />

    <!-- Prism JS for highlighting logic -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>

    <!-- Optional: Add language support you need -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-rust.min.js"></script>

</head>

<body>
    <header>
        <h1>Project Name</h1>
        <p>A brief description of what the project does</p>
    </header>

    <div class="container">
        <div class="section">
            <h2>Table of Contents</h2>
            <ul>
                <li><a href="#overview">Project Overview</a></li>
                <li><a href="#library">How to use the library</a></li>
                <li><a href="#installation">Installation Guide</a></li>
                <li><a href="#usage">Usage</a></li>
                <li><a href="#code">Code Structure</a></li>
                <li><a href="#contributing">Contributing</a></li>
            </ul>
        </div>

        <div class="section" id="overview">
            <h2>Project Overview</h2>
            <p>This project is a brief description of the overall purpose and goal of your code. Explain the problem it solves, its main features, and what sets it apart from other similar projects.</p>
        </div>

        <div class="section" id="library">
            <h2>How to use the library</h2>
            <p>
                You start with creating a mutable CardGameModel variable:
            </p>
            <pre><code class="language-rust">
        let mut cgm = CardGameModel::new("MyCardGame");
            </code></pre>
            <h3> Setup </h3>
            <p>
                At first you have to set up the preliminaries of the game. For that you can use the setup-macro as followed:
            </p>
            <pre><code class="language-rust">
                let mut cgm = CardGameModel::new("MyCardGame");

                setup!(
                    &mut cgm.gamedata,
                );
            </code></pre>
            <p>
                setup!() takes a &mut GameData as a mandatory first argument. <br>
                Now we can set the framework of the game with some predefined keywords. The syntax generally looks like this:
            </p>
            <pre><code class="language-rust">
                keyword: input1, input2,
            </code></pre>
            <p>
                The possible keywords are:
            </p>
            <h4> player </h4>
            <p>
                To add players you need to give the Model their names as Strings.<br>
            </p>
            <pre><code class="language-rust">
        // Initializing the model
        let mut cgm = CardGameModel::new("MyCardGame");

        // Initializing the setup
        setup!(
            &mut cgm.gamedata,

            // Adding players to the model
            player: "Jimmy", "Timmy", "Kimmy",
        );
            </code></pre>
       
            <h4> teams </h4>
            <p>
                Let's say we need teams in our game.<br>
                And let's also say that nobody likes "Kimmy".<br>
                This can be done like this:<br>
            </p>
            <pre><code class="language-rust">
        // Initializing the model
        let mut cgm = CardGameModel::new("MyCardGame");

        // Initializing the setup
        setup!(
            &mut cgm.gamedata,

            // Adding players to the model
            player: "Jimmy", "Timmy", "Kimmy",

            // Adding teams to the model
            teams: "TheBestTeam", ("Jimmy", "Timmy"),
            teams: "TheWorstTeam", ("Kimmy"),
        );
            </code></pre>
            <p>
                First you give the team a name than in brakets you add players to that team, all as Strings.
            </p>

            <h4> location </h4>

            <p>
                Now we have our players and teams. BUT WHERE ARE THE CARDS?<br>
                Do we have a Card-Stack? Where are the Players-Cards located?<br>
                We first should declare some locations where cards can be placed!<br>
            </p>

            <pre><code class="language-rust">
        // Initializing the model
        let mut cgm = CardGameModel::new("MyCardGame");

        // Initializing the setup
        setup!(
            &mut cgm.gamedata,

            // Adding players to the model
            player: "Jimmy", "Timmy", "Kimmy",

            // Adding teams to the model
            teams: "TheBestTeam", ("Jimmy", "Timmy"),
            teams: "TheWorstTeam", ("Kimmy"),

            // Add location 'hand' to each player
            location: "hand", players: "Jimmy", "Timmy", "Kimmy",

            // Add a stack to the table
            location: "stack", table,

        );
            </code></pre>
            <p>
                First we give the location a name. Now we specify the owner with 3 additional keywords: <br>
                <i>table</i> when want an general location owned by no one. <br>
                <i>players</i> for locations owned by a player. <br>
                <i>team</i> for locations owned by a player. <br>
                <br>
                <b>Important:</b> The syntax differs for each keyword.
            </p>
            <pre><code class="language-rust">
                // table
                location: "loaction-name", table,

                // team
                loaction: "location-name", team: "target-team",

                // players
                location: "location-name", players: "target-player1", "target-player2",     
            </code></pre>
            <p> 
                table has no target, team one possible target and players can have multiple possible targets.
            </p>

            <h4> cards </h4>

            <p>
                Now we have almost everything Set-Up for a Card Game!<br>
                But ... where are the Cards?<br>
                What kind of Cards do we need?<br>
                What is a Card?<br>

                A Card in our Game-Context:<br>
                // TODO: Add Definition of our Card<br>
                - has Attributes:<br>
                    > For Example:<br>
                        - Rank:  (2, 3, 4, 5, 6, 7, ...)<br>
                        - Suite: (Clubs, Spades, Hearts, Diamonds)<br>
                    > Example for a Card:<br>
                        - CardExample:<br>
                            Rank  = 6<br>
                            Suite = Clubs<br>
                <br>
                These Atrributes can be completely arbitrary!<br>
                <br>
                Now where do we need Cards for the Set-Up of the Game?<br>
                Let's say we have all our Cards in the Stack on the Table:<br>
            </p>

            <pre><code class="language-rust">
        // Initializing the model
        let mut cgm = CardGameModel::new("MyCardGame");

        // Initializing the setup
        setup!(
            &mut cgm.gamedata,

            // Adding players to the model
            player: "Jimmy", "Timmy", "Kimmy",

            // Adding teams to the model
            teams: "TheBestTeam", ("Jimmy", "Timmy"),
            teams: "TheWorstTeam", ("Kimmy"),

            // Add location 'hand' to each player
            location: "hand", players: "Jimmy", "Timmy", "Kimmy",

            // Add a stack to the table
            location: "stack", table,

            // Create cards on the location 'stack'
            cards:  
                "stack",
                {
                    Rank("2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"),
                    Suite("Diamond", "Hearts"),
                    Color("Red")
                },
                {
                    Rank("2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"),
                    Suite("Spades", "Clubs"),
                    Color("Black")
                },
        );
            </code></pre>

            <pre><code class="language-rust">
                cards: "target-location", { (key((value: String), *)), *},
            </code></pre>
            <p>
                cards computes the Cross-Product of the inside of '{''}'.<br>
                In the Example we declare Cards with the Color 'Black' and 'Red' seperately, because of the Cross-Product!<br>
            </p>

            <h4> Precedence </h4>

            <p>
                Now we have Cards!<br>
                For lots games (e.g. Trick-Taking-Games) the importance of a Card-Precedence is very important.<br>
                What we mean with Card-Precedence is: Which Card is higher, lower or the same to another Card. <br>
            </p>
        
            <pre><code class="language-rust">
        // Initializing the model
        let mut cgm = CardGameModel::new("MyCardGame");

        // Initializing the setup
        setup!(
            &mut cgm.gamedata,

            // Adding players to the model
            player: "Jimmy", "Timmy", "Kimmy",

            // Adding teams to the model
            teams: "TheBestTeam", ("Jimmy", "Timmy"),
            teams: "TheWorstTeam", ("Kimmy"),

            // Add location 'hand' to each player
            location: "hand", players: "Jimmy", "Timmy", "Kimmy",

            // Add a stack to the table
            location: "stack", table,

            // Create cards on the location 'stack'
            cards:  
                "stack",
                {
                    Rank("2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"),
                    Suite("Diamond", "Hearts"),
                    Color("Red")
                },
                {
                    Rank("2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"),
                    Suite("Spades", "Clubs"),
                    Color("Black")
                },
            
            // Creating a precedence on the attribute 'Rank'
            precedence: "Rank", ("2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"),
        );
            </code></pre>

            <p>
                The lowest Precedence is Rank=2 and the highest is Rank=A.
            </p>

            <h4> pointmap </h4>

            <p>
                However, we might want to give arbitrary values and maybe multiple values!<br>
                For this we use a PointMap<br>
                A PointMap assigns a vector of values to an attribute.<br>
                In 'Black Jack' the Ace can have 1 or 11 as a value!<br> 
            </p>

            <pre><code class="language-rust">
        // Initializing the model
        let mut cgm = CardGameModel::new("MyCardGame");

        // Initializing the setup
        setup!(
            &mut cgm.gamedata,

            // Adding players to the model
            player: "Jimmy", "Timmy", "Kimmy",

            // Adding teams to the model
            teams: "TheBestTeam", ("Jimmy", "Timmy"),
            teams: "TheWorstTeam", ("Kimmy"),

            // Add location 'hand' to each player
            location: "hand", players: "Jimmy", "Timmy", "Kimmy",

            // Add a stack to the table
            location: "stack", table,

            // Create cards on the location 'stack'
            cards:  
                "stack",
                {
                    Rank("2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"),
                    Suite("Diamond", "Hearts"),
                    Color("Red")
                },
                {
                    Rank("2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"),
                    Suite("Spades", "Clubs"),
                    Color("Black")
                },

            // We create a PointMap (for the Special case 'Black Jack')
            pointmap:  
                "BlackJackRank",
                nested: {  
                    "Rank", (
                    "2" => [2],
                    "3" => [3],
                    "4" => [4],
                    "5" => [5],
                    "6" => [6],
                    "7" => [7],
                    "8" => [8],
                    "9" => [9],
                    "T" => [10],
                    "J" => [10],
                    "Q" => [10],
                    "K" => [10],
                    "A" => [11, 1]
                    )
                },
        );
            </code></pre>

            <p>
                There is also another way to declare this PointMap:  
            </p>

            <pre><code class="language-rust">
        // Initializing the Model
        let mut cgm = CardGameModel::new("MyCardGame");

        // Initializing the setup
        setup!(

        ...

        // We create a PointMap (for the Special case 'Black Jack')
        pointmap:
            "BlackJackRank",
            list: {  
                ("Rank", "2") => [2],
                ("Rank", "3") => [3],
                ("Rank", "4") => [4],
                ("Rank", "5") => [5],
                ("Rank", "6") => [6],
                ("Rank", "7") => [7],
                ("Rank", "8") => [8],
                ("Rank", "9") => [9],
                ("Rank", "T") => [10],
                ("Rank", "J") => [10],
                ("Rank", "Q") => [10],
                ("Rank", "K") => [10],
                ("Rank", "A") => [1, 11],
            },
        );
            </code></pre>

            <p>
                You can also combine these two:
            </p>

            <pre><code class="language-rust">
        // Initializing the Model
        let mut cgm = CardGameModel::new("MyCardGame");

        // Initializing the setup
        setup!(

        ...

        // We create a PointMap (for the Special case 'Black Jack')
        pointmap:
            "BlackJackRank",
            nested: {  
                "Rank", (
                "2" => [2],
                "3" => [3],
                "4" => [4],
                "5" => [5],
                "6" => [6],
                "7" => [7],
                "8" => [8],
                "9" => [9],
                "T" => [10],
                "J" => [10],
                "Q" => [10],
                "K" => [10],
                "A" => [11, 1]
                )
            },
            list: {  
                ("Suite", "Clubs")    => [10],
                ("Suite", "Spades")   => [1],
                ("Suite", "Hearts")   => [1],
                ("Suite", "Diamonds") => [1],
            },
        );
            </code></pre>


            <p>
                Another use of PointMap would be to declare a special Point-Distribution (e.g. in a Trick).<br>
                In the german game 'Skat', we have a distribution like this:<br>
                7, 8, 9 => [0]<br>
                J => [2]<br>
                Q => [3]<br>
                K => [4]<br>
                T => [10]<br>
                A => [11]<br>
                <br>
                <b>Important:</b> This assigning of points is not possible with precedence!
            </p>

            <h3> Card-Combination </h3>
            
            <p>
                In some Card-Games you have to look at multiple Cards to identify a Card-Combination.<br>
                In Poker (Texas hold'em) there is a 'Flush'.<br>
                Out of the 7 Cards we check if at least 5 Cards have the same 'Suite'.<br>
                We can declare a Combination for our model:
            </p>

            <pre><code class="language-rust">
        // Initializing the Model
        let mut cgm = CardGameModel::new("MyCardGame");

        ...

        combo!("Flush", (
            filter!(
                (same "Suite"),
                ("and"),
                (size ">=" 5))
            )
        )(&mut cgm.gamedata);
            </code></pre>

            <p>
                We can 'save' this Combo in our GameData and the call it by the name "Flush" when we need it!<br>
                What is this 'filter!(...)' and how can we declare it?<br>  
            </p>
            <p>
                // TODO: Memory and other missing things in Set-Up
            </p>
            <p>
                The filter!(...) is a Macros that takes a Vector of Cards (and also a GameData, because that is where the Cards are in the Game) and <br>
                applies the filter!(...) on the Cards. If the filter!(...) cannot find a fitting subset of the Cards that satisfy it, then it will be empty.<br>
                (For further information on how the filter!(...)-Macros works look in the code. There is a detailed description on how it works.)
            </p>
            <pre><code class="language-rust">
        // same Attribute
        filter!(same (attr_name: &str));

        // Example:
        filter!(same "Rank");

        // adjacent Attribute using Precedence
        filter!(adjacent (attr_name: &str) using (prec_name: &str));

        // Example
        precedence!("RankPrecedence", ("2", "3", "4", "5", "6", "7", "8", "9", "T", "J", "Q", "K", "A"))(&mut cgm.gamedata);
        filter!(adjacent "Rank" using "RankPrecedence");

        // size comparison value
        filter!(size (comparison: &str) value);

        // Example
        filter!(size ">" 3);

        // Attribute "==" Attribute-Value
        filter!((attr_key: &str) "==" (attr_value: &str));

        // Example
        filter!("Rank" "==" "A");

        // Attribute "!=" Attribute-Value
        filter!((attr_key: &str) "!=" (attr_value: &str));

        // Example
        filter!("Rank" "!=" "A");

        // combo
        filter!((comboname: &str));

        // Example
        filter!("MyCombo");

        // not combo
        filter!(not (comboname: &str));

        // Example
        filter!(not "MyCombo");

        // Combined filter with 'and'
        // Example:
        filter!(
            (same "Suite"),
            ("and"),
            (size ">=" 5)
        );

        // Combined filter with 'or'
        // Example:
        filter!(
            (same "Suite"),
            ("or"),
            (size ">=" 5)
        );
            </code></pre>
        
            <p>
                This wraps up the Set-Up for our Card Game.
            </p>

            <h3> RuleSet </h3>

            <p>
                We now know how to Set-Up a Card Game!<br>
                Let's get to the core of any Card Game:<br>
                The Rules!
            </p>

            <p>
                We can define a rough structure of Rules with 'Stages'.<br>
                A 'Stage' is an useful tool for decalring the Rules.<br>
                We can declare different Rules and Game-Cycles with it which makes creating a Game more flexible.<br>
                <br>
                However, we first need to understand the Rules and the tools that we are working with.  
            </p>

            <h3> Rules </h3>

            <p>
                Conditional-Rule:<br>
                    case (b: bool):<br>
                        'Rule'<br>
                    case (b: bool):<br>
                        'Rule'<br>
                    case (b: bool):<br>
                        'Rule'<br>
                    ...<br>
            </p>

            <p>
                If-Rule:<br>
                    if (b: bool) then<br>
                        'Rule'<br>
            </p>

            <p>
                Optional-Rule:<br>
                    'Rule'<br>
            </p>

            <p>
                Choose-Rule:<br>
                        'Rule'<br>
                    OR:<br>
                        'Rule'<br>
                    OR:<br>
                        'Rule'<br>
                    OR:<br>
                    ...<br>
            </p>

            <p>
                Trigger-Rule:<br>
                    'Rule'<br>
            </p>

            <p>
                Action-Rule:<br>
                    'Action'<br>
            </p>


            
            
        </div>
    </body>

</html>
